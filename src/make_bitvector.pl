#!/usr/bin/perl -w
#
# A Perl script to convert tables represented by strings of characters
# into bit vector tables.
#
# Written by Paul A. Rombouts
#
# This file Copyright 2002 Paul A. Rombouts
# It may be distributed under the GNU Public License, version 2, or
# any higher version.  See section COPYING of the GNU Public license
# for conditions under which this file may be redistributed.
#

use strict;
use integer;

my $linectrl=0; my $lcfile;
while(@ARGV && $ARGV[0] =~ /^-/) {
    if($ARGV[0] =~ /^-{0,2}([[:alpha:]]\w*)(?:=(.*))?$/s) {
	my $param=lc($1); my $valstr=$2;
	if($param eq 'linectrl') {
	    $linectrl=1; $lcfile=$valstr;
	}
        else {die "Unknown option specified in command line: $ARGV[0]\n"}
    }
    else {die "Unknown option specified in command line: $ARGV[0]\n"}
    shift @ARGV;
}

sub linectrl {
    my($lnr)= @_;
    $lnr= $. unless defined($lnr);
    (my $qufn=(defined($lcfile)?$lcfile:$ARGV)) =~ s/[\"\\]/\\$&/g;
    return "#line $lnr \"$qufn\"\n";
}

print "/*
   This file was generated using $0.
   Do not edit this file, because your changes will be lost the next time $0 is run.
   Edit @ARGV instead.
*/
";

my $modlnr=1;
while(<>) {
    if(/^__BITVECTOR__$/) {
	$modlnr=1;
	my $prev=0;
	while(<>) {
	    if($linectrl && $modlnr) {print linectrl; $modlnr=0}
	    chomp;
	    if($_ eq '') {last}
	    my $orig_text=$_;
	    my $bits=join '', map {($_ ne ' ')+0} (split //);
	    my $len= length($bits);
	    print '  ';
	    for(my $i=0; $i<$len; $i+=8) {
		print($prev?',':' ');
		printf("0x%02x",ord(pack("b8",substr($bits,$i,8))));
		$prev=1;
	    }
	    print "  /*$orig_text*/\n";
	}
	$modlnr=1;
    }
    elsif(/^__INV(CASE)?CHARMAP__$/) {
	$modlnr=1;
	my $caseins=$1;
	my $line='';
	while(<>) {
	    if($linectrl && $modlnr) {print linectrl; $modlnr=0}
	    if($_ eq "\n") {last}
	    $line .= $_;
	}
	my @map=(eval "($line)");
	my %invmap=();
	for(my $i=0; $i<@map; ++$i) {
	    foreach my $c (split //,$map[$i]) {
		$invmap{$c}=$i;
		if($caseins) {
		    $invmap{lc($c)}=$i;
		    $invmap{uc($c)}=$i;
		}
	    }
	}
	for(my $i=0; $i<256; ++$i) {
	    print($i==0?"  ":($i % 16)?",":",\n  ");
	    my $val=$invmap{chr($i)};
	    printf("%3d",defined($val)?$val:0);
	}
	print "\n";
	$modlnr=1;
    }
    else {
	if($linectrl && ($modlnr || $.== 1)) {
	    print linectrl;
	    $modlnr=0;
	}
	print;
    }    
} continue {
    close ARGV  if eof;
}

